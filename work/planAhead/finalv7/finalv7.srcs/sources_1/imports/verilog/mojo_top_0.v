/*
   This file was generated automatically by the Mojo IDE version B1.3.6.
   Do not edit this file directly. Instead edit the original Lucid source.
   This is a temporary file and any changes made to it will be destroyed.
*/

module mojo_top_0 (
    input clk,
    input rst_n,
    output reg [7:0] led,
    input cclk,
    output reg spi_miso,
    input spi_ss,
    input spi_mosi,
    input spi_sck,
    output reg [3:0] spi_channel,
    input avr_tx,
    output reg avr_rx,
    input avr_rx_busy,
    output reg [23:0] io_led,
    output reg [7:0] io_seg,
    output reg [3:0] io_sel,
    input [4:0] io_button,
    input [23:0] io_dip
  );
  
  
  
  reg rst;
  
  reg [15:0] value;
  
  reg [3:0] alufn;
  
  reg [15:0] out;
  
  reg [24:0] M_counter_d, M_counter_q = 1'h0;
  
  integer on;
  
  integer off;
  
  wire [2-1:0] M_test_adder_status;
  reg [1-1:0] M_test_adder_clk;
  reg [1-1:0] M_test_adder_rst;
  reg [1-1:0] M_test_adder_start;
  test_adder_1 test_adder (
    .clk(M_test_adder_clk),
    .rst(M_test_adder_rst),
    .start(M_test_adder_start),
    .status(M_test_adder_status)
  );
  
  wire [2-1:0] M_test_compare_status;
  reg [1-1:0] M_test_compare_clk;
  reg [1-1:0] M_test_compare_rst;
  reg [1-1:0] M_test_compare_start;
  test_compare_2 test_compare (
    .clk(M_test_compare_clk),
    .rst(M_test_compare_rst),
    .start(M_test_compare_start),
    .status(M_test_compare_status)
  );
  
  wire [2-1:0] M_test_boole_status;
  reg [1-1:0] M_test_boole_clk;
  reg [1-1:0] M_test_boole_rst;
  reg [1-1:0] M_test_boole_start;
  test_boole_3 test_boole (
    .clk(M_test_boole_clk),
    .rst(M_test_boole_rst),
    .start(M_test_boole_start),
    .status(M_test_boole_status)
  );
  
  wire [2-1:0] M_test_shifter_status;
  reg [1-1:0] M_test_shifter_clk;
  reg [1-1:0] M_test_shifter_rst;
  reg [1-1:0] M_test_shifter_start;
  test_shifter_4 test_shifter (
    .clk(M_test_shifter_clk),
    .rst(M_test_shifter_rst),
    .start(M_test_shifter_start),
    .status(M_test_shifter_status)
  );
  
  wire [2-1:0] M_test_multiply_status;
  reg [1-1:0] M_test_multiply_clk;
  reg [1-1:0] M_test_multiply_rst;
  reg [1-1:0] M_test_multiply_start;
  test_multiply_5 test_multiply (
    .clk(M_test_multiply_clk),
    .rst(M_test_multiply_rst),
    .start(M_test_multiply_start),
    .status(M_test_multiply_status)
  );
  
  wire [2-1:0] M_test_error_status;
  reg [1-1:0] M_test_error_clk;
  reg [1-1:0] M_test_error_rst;
  reg [1-1:0] M_test_error_start;
  test_error_6 test_error (
    .clk(M_test_error_clk),
    .rst(M_test_error_rst),
    .start(M_test_error_start),
    .status(M_test_error_status)
  );
  
  wire [7-1:0] M_seg_seg;
  wire [4-1:0] M_seg_sel;
  reg [1-1:0] M_seg_clk;
  reg [1-1:0] M_seg_rst;
  reg [16-1:0] M_seg_values;
  multi_seven_seg_7 seg (
    .clk(M_seg_clk),
    .rst(M_seg_rst),
    .values(M_seg_values),
    .seg(M_seg_seg),
    .sel(M_seg_sel)
  );
  
  wire [16-1:0] M_combine_out;
  reg [16-1:0] M_combine_a;
  reg [16-1:0] M_combine_b;
  reg [5-1:0] M_combine_alufn;
  functionCombi_8 combine (
    .a(M_combine_a),
    .b(M_combine_b),
    .alufn(M_combine_alufn),
    .out(M_combine_out)
  );
  
  
  localparam IDLE_state = 3'd0;
  localparam ADDER_state = 3'd1;
  localparam COMPARE_state = 3'd2;
  localparam BOOLE_state = 3'd3;
  localparam SHIFTER_state = 3'd4;
  localparam MULTIPLY_state = 3'd5;
  localparam ERROR_state = 3'd6;
  
  reg [2:0] M_state_d, M_state_q = IDLE_state;
  
  
  localparam IDLE_alu = 1'd0;
  localparam AUTO_alu = 1'd1;
  
  reg M_alu_d, M_alu_q = IDLE_alu;
  
  reg [15:0] M_a_d, M_a_q = 1'h0;
  
  reg [15:0] M_b_d, M_b_q = 1'h0;
  
  wire [1-1:0] M_reset_cond_out;
  reg [1-1:0] M_reset_cond_in;
  reset_conditioner_9 reset_cond (
    .clk(clk),
    .in(M_reset_cond_in),
    .out(M_reset_cond_out)
  );
  
  always @* begin
    M_alu_d = M_alu_q;
    M_state_d = M_state_q;
    M_b_d = M_b_q;
    M_counter_d = M_counter_q;
    M_a_d = M_a_q;
    
    M_reset_cond_in = ~rst_n;
    rst = M_reset_cond_out;
    led = 8'h00;
    spi_miso = 1'bz;
    spi_channel = 4'bzzzz;
    avr_rx = 1'bz;
    io_led = 24'h000000;
    io_seg = 8'hff;
    io_sel = 4'hf;
    out = 16'h0000;
    value[0+7-:8] = io_dip[0+7-:8];
    value[8+7-:8] = io_dip[8+7-:8];
    io_led[0+15-:16] = out;
    alufn = io_dip[16+0+3-:4];
    on = 8'hff;
    off = 8'h00;
    M_test_adder_clk = clk;
    M_test_adder_rst = rst;
    M_test_error_clk = clk;
    M_test_error_rst = rst;
    M_test_compare_clk = clk;
    M_test_compare_rst = rst;
    M_test_boole_clk = clk;
    M_test_boole_rst = rst;
    M_test_shifter_clk = clk;
    M_test_shifter_rst = rst;
    M_test_multiply_clk = clk;
    M_test_multiply_rst = rst;
    M_seg_clk = clk;
    M_seg_rst = rst;
    M_combine_a = 1'h0;
    M_combine_b = 1'h0;
    M_combine_alufn = 1'h0;
    M_test_adder_start = 1'h0;
    M_test_compare_start = 1'h0;
    M_test_boole_start = 1'h0;
    M_test_shifter_start = 1'h0;
    M_test_multiply_start = 1'h0;
    M_test_error_start = 1'h0;
    M_seg_values = 16'hffff;
    io_seg = ~M_seg_seg;
    io_sel = ~M_seg_sel;
    io_led[16+6+1-:2] = io_dip[16+6+1-:2];
    io_led[0+7-:8] = io_dip[0+7-:8];
    io_led[8+7-:8] = io_dip[8+7-:8];
    if (io_dip[16+7+0-:1] == 1'h1 & io_dip[16+6+0-:1] == 1'h0) begin
      M_a_d = value;
    end else begin
      if (io_dip[16+6+0-:1] == 1'h1 & io_dip[16+7+0-:1] == 1'h0) begin
        M_b_d = value;
      end else begin
        if (io_dip[16+6+0-:1] == 1'h1 & io_dip[16+7+0-:1] == 1'h1) begin
          M_combine_a = M_a_q;
          M_combine_b = M_b_q;
          M_combine_alufn = io_dip[16+0+4-:5];
          io_led[0+7-:8] = M_combine_out[0+7-:8];
          io_led[8+7-:8] = M_combine_out[8+7-:8];
        end
      end
    end
    
    case (M_alu_q)
      IDLE_alu: begin
        led = on;
        if (io_button[3+0-:1]) begin
          M_alu_d = AUTO_alu;
        end
      end
      AUTO_alu: begin
        if (io_dip[16+7+0-:1] == 1'h1 & io_dip[16+6+0-:1] == 1'h0) begin
          led = 8'hfe;
          M_a_d = value;
        end else begin
          if (io_dip[16+6+0-:1] == 1'h1 & io_dip[16+7+0-:1] == 1'h0) begin
            M_b_d = value;
          end
        end
        led = off;
        M_combine_a = M_a_q;
        M_combine_b = M_b_q;
        M_combine_alufn = alufn;
        io_led[0+7-:8] = M_combine_out[0+7-:8];
        io_led[8+7-:8] = M_combine_out[8+7-:8];
        
        case (M_state_q)
          IDLE_state: begin
            M_counter_d = 1'h0;
            led = 8'hfc;
          end
          ADDER_state: begin
            led = 8'hf8;
            M_test_adder_start = 1'h1;
            if (M_test_adder_status == 1'h1) begin
              M_seg_values = 16'hab55;
            end else begin
              if (M_test_adder_status == 2'h2) begin
                M_seg_values = 16'hb00d;
              end
            end
          end
          COMPARE_state: begin
            M_test_compare_start = 1'h1;
            led = 8'hf0;
            if (M_test_compare_status == 1'h1) begin
              M_seg_values = 16'hab55;
            end else begin
              if (M_test_compare_status == 2'h2) begin
                M_seg_values = 16'he0ad;
              end
            end
          end
          BOOLE_state: begin
            M_test_boole_start = 1'h1;
            led = 8'he0;
            if (M_test_boole_status == 1'h1) begin
              M_seg_values = 16'hab55;
            end else begin
              if (M_test_boole_status == 2'h2) begin
                M_seg_values = 16'h800d;
              end
            end
          end
          SHIFTER_state: begin
            M_test_shifter_start = 1'h1;
            led = 8'hc0;
            if (M_test_shifter_status == 1'h1) begin
              M_seg_values = 16'hab55;
            end else begin
              if (M_test_shifter_status == 2'h2) begin
                M_seg_values = 16'h5c1d;
              end
            end
          end
          MULTIPLY_state: begin
            M_test_multiply_start = 1'h1;
            led = 8'h80;
            if (M_test_multiply_status == 1'h1) begin
              M_seg_values = 16'hab55;
            end else begin
              if (M_test_multiply_status == 2'h2) begin
                M_seg_values = 16'h234d;
              end
            end
          end
          ERROR_state: begin
            M_test_error_start = 1'h1;
            led = 8'haa;
            if (M_test_error_status == 1'h1) begin
              M_seg_values = 16'hab55;
            end else begin
              if (M_test_error_status == 2'h2) begin
                M_seg_values = 16'hb00d;
              end
            end
          end
        endcase
        if (io_button[0+0-:1]) begin
          M_counter_d = 1'h0;
          M_state_d = ADDER_state;
          if (io_dip[16+7+0-:1] == 1'h1 && io_dip[16+6+0-:1] == 1'h1) begin
            M_counter_d = 1'h0;
            M_state_d = ERROR_state;
          end
        end
        if (io_button[1+0-:1]) begin
          M_counter_d = 1'h0;
          M_state_d = COMPARE_state;
        end
        if (io_button[2+0-:1]) begin
          M_counter_d = 1'h0;
          M_state_d = BOOLE_state;
        end
        if (io_button[3+0-:1]) begin
          M_counter_d = 1'h0;
          M_state_d = SHIFTER_state;
        end
        if (io_button[4+0-:1]) begin
          M_counter_d = 1'h0;
          M_state_d = MULTIPLY_state;
        end
        M_counter_d = M_counter_q + 1'h1;
        io_led[0+7-:8] = M_combine_out[0+7-:8];
        io_led[8+7-:8] = M_combine_out[8+7-:8];
      end
    endcase
  end
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_alu_q <= 1'h0;
    end else begin
      M_alu_q <= M_alu_d;
    end
  end
  
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_b_q <= 1'h0;
    end else begin
      M_b_q <= M_b_d;
    end
  end
  
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_state_q <= 1'h0;
    end else begin
      M_state_q <= M_state_d;
    end
  end
  
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_counter_q <= 1'h0;
    end else begin
      M_counter_q <= M_counter_d;
    end
  end
  
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_a_q <= 1'h0;
    end else begin
      M_a_q <= M_a_d;
    end
  end
  
endmodule
